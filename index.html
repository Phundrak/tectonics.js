<!doctype html>
<html>
<head>
    <title>Tectonics.js - 3d plate tectonics in your web browser</title>
    <!--If using any IE, don't even bother-->
    <!--[if IE]>
        <meta http-equiv="refresh" content="0;url=ie.html" />
    <![endif]-->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">

    <link rel="icon" type="text/css" href="blog/icon6.png">
    <link rel="stylesheet" href="styles/bootstrap.min.css">
    <link rel="stylesheet" href="styles/main.css"/>
    <link rel="stylesheet" href="styles/app.css"/>

    <script src="libraries/jquery-1.10.2.min.js"></script>
    <script src="libraries/vue.js"></script>
    <script src="libraries/Chart.js"></script>
    <script src="libraries/vue-charts.js"></script>
    <script src="libraries/bootstrap.bundle.min.js"></script>
    <script src="libraries/three.js/Three.js"></script>
    <script src="libraries/three.js/OrbitControls.js"></script>
    <script src="libraries/three.js/CopyShader.js"></script>
    <script src="libraries/three.js/EffectComposer.js"></script>
    <script src="libraries/three.js/RenderPass.js"></script>
    <script src="libraries/three.js/ShaderPass.js"></script>
    <script src="libraries/Stats.js"></script>
    <script src="libraries/random-0.26.js"></script>
    <script src="libraries/base64-arraybuffer.js"></script>
    <script src="postcompiled/Shaders.js"></script>
    <script src="postcompiled/Rasters.js"></script>
    <script src="noncompiled/Units.js"></script>
    <script src="noncompiled/Interpolation.js"></script>
    <script src="noncompiled/Logging.js"></script>
    <script src="noncompiled/Event.js"></script>
    <script src="noncompiled/academics/SphericalGeometry.js"></script>
    <script src="noncompiled/academics/Optics.js"></script>
    <script src="noncompiled/academics/Thermodynamics.js"></script>
    <script src="noncompiled/academics/FluidMechanics.js"></script>
    <script src="noncompiled/academics/OrbitalMechanics.js"></script>
    <script src="noncompiled/academics/Tectonophysics.js"></script>
    <script src="noncompiled/academics/Hydrology.js"></script>
    <script src="noncompiled/academics/Climatology.js"></script>
    <script src="noncompiled/academics/PlantBiology.js"></script>
    <script src="noncompiled/models/Memo.js"></script>
    <script src="noncompiled/models/universe/Orbit.js"></script>
    <script src="noncompiled/models/universe/Spin.js"></script>
    <script src="noncompiled/models/universe/Star.js"></script>
    <script src="noncompiled/models/universe/CelestialCycle.js"></script>
    <script src="noncompiled/models/universe/Universe.js"></script>
    <script src="noncompiled/models/lithosphere/Crust.js"></script>
    <script src="noncompiled/models/lithosphere/RockColumn.js"></script>
    <script src="noncompiled/models/lithosphere/Plate.js"></script>
    <script src="noncompiled/models/lithosphere/SupercontinentCycle.js"></script>
    <script src="noncompiled/models/lithosphere/Lithosphere.js"></script>
    <script src="noncompiled/models/hydrosphere/Hydrosphere.js"></script>
    <script src="noncompiled/models/atmosphere/Atmosphere.js"></script>
    <script src="noncompiled/models/biosphere/Biosphere.js"></script>
    <script src="noncompiled/models/World.js"></script>
    <script src="noncompiled/models/Simulation.js"></script> 
    <script src="noncompiled/generators/CrustGenerator.js"></script>
    <script src="noncompiled/generators/NameGenerator.js"></script>
    <script src="noncompiled/generators/NameCorpii.js"></script>
    <script src="noncompiled/file-io/JsonSerializer.js"></script>
    <script src="noncompiled/file-io/CsvExporter.js"></script>
    <script src="noncompiled/file-io/ImageImporter.js"></script>
    <script src="noncompiled/views/raster-views/PdfChartRasterView.js"></script>
    <script src="noncompiled/views/raster-views/ColorscaleRasterView.js"></script>
    <script src="noncompiled/views/raster-views/HeatmapRasterView.js"></script>
    <script src="noncompiled/views/raster-views/TopographicRasterView.js"></script>
    <script src="noncompiled/views/raster-views/SurfaceNormalMapRasterView.js"></script>
    <script src="noncompiled/views/raster-views/DisabledVectorRasterView.js"></script>
    <script src="noncompiled/views/raster-views/VectorRasterView.js"></script>
    <script src="noncompiled/views/world-views/RealisticWorldView.js"></script>
    <script src="noncompiled/views/world-views/ScalarWorldView.js"></script>
    <script src="noncompiled/views/world-views/VectorWorldView.js"></script>
    <script src="noncompiled/views/projection-views/MapProjectionView.js"></script>
    <script src="noncompiled/views/projection-views/GlobeProjectionView.js"></script>
    <script src="noncompiled/views/ScalarViews.js"></script>
    <script src="noncompiled/views/VectorViews.js"></script>
    <script src="noncompiled/views/ProjectionViews.js"></script>
    <script src="noncompiled/views/RegressionTestViews.js"></script>
    <script src="noncompiled/views/ExperimentalViews.js"></script>
    <!-- <script src="noncompiled/views/TestViews.js"></script> -->
    <script src="noncompiled/views/View.js"></script>
</head>
<body>
<!-- three.js container -->
<div id="container"></div>
<!-- logo -->
<div id="header">
    <h1><a href="blog/">Tectonics.js</a></h1>
    <div id="navigation">
        <a href="blog/index.html">ABOUT</a>&nbsp;
        <a href="blog/news.html">BLOG</a>&nbsp;
        <a href="blog/credits.html">CREDITS</a>&nbsp;
        <a href="http://github.com/davidson16807/tectonics.js">CODE</a>&nbsp;
    </div>
</div>
<!-- info on screen display -->
<div id="main-control" class="show collapse control" >
    <div class="vertical-axis-group">
        <div class="horizontal-axis-group">
            <span id='age-display' class="form-control input">{{ format_count(elapsed_time).quantity }}</span>
            <div id='age-units-display' class="input-group-append">
                <span class="input-group-text age-units">{{ format_count(elapsed_time).unit }}y</span>
            </div>
        </div>
        <div class="horizontal-axis-group">
            <div class="input-group-prepend">
                <span class="input-group-text play" v-on:click="togglePause()">
                    <img src="icons/pause.svg" v-if="!paused"/>
                    <img src="icons/play.svg"  v-if="paused"/>
                </span>
                <span class="input-group-text" v-on:click="slower()">
                    <img src="icons/step-forward.svg"/>
                </span>
                <span class="input-group-text fast-forward" v-on:click="faster()">
                    <img src="icons/fast-forward.svg"/>
                </span>
            </div>
            <div class="input-group-append">
                <span id="speed-display" class="input-group-text">
                    {{speeds[speed_i].name}}
                    <span class="instructions">&lt;/&gt;</span>
                </span>
            </div>
        </div>
    </div>

    <div class="short-axis-group">
        <button type="button" class="btn" data-toggle="collapse" data-target=".tune-control, #main-control">
            <img src="icons/tune.svg"/>
            Tune 
        </button>
        <button type="button" class="btn" data-toggle="collapse" data-target="#view-control, #main-control">
            <img src="icons/eye.svg"/>
            View 
        </button>
        <button type="button" class="btn" data-toggle="collapse" data-target="#file-control, #main-control">
            <img src="icons/folder.svg"/>
            File 
        </button>
    </div>
</div>

<div id="file-control" class="collapse control" >
    <div class="short-axis-group">
        <button type="button" class="btn" data-toggle="collapse" data-target="#file-control, #main-control">
            <img src="icons/down-arrow.svg"/>
            Return
        </button>
        <button id="screenshot" v-if="isEnabled" type="button" class="btn" v-on:click="capture" v-on:keyup.p="capture">
            <img src="icons/camera.svg"/>
            Screenshot
            <span class="instructions">p</span>
        </button>
        <div id="export" class="short-axis-group">
            <button type="button" class="btn" data-toggle="collapse" data-target="#export-menu" aria-haspopup="true" aria-expanded="false">
                <img src="icons/export.svg"/>
                Export
            </button>
            <div id="export-menu" class="collapse">
                <button type="button" 
                    class="btn" 
                    v-on:click="csv">
                    <img src="icons/view-list.svg"/>
                    CSV
                </button>
            </div>
        </div>
        <div id="import" class="short-axis-group">
            <button type="button" class="btn" data-toggle="collapse" data-target="#import-menu" aria-haspopup="true" aria-expanded="false">
                <img src="icons/import.svg"/>
                Import
            </button>
            <div id="import-menu" class="collapse">
                <button type="button" 
                    class="btn" 
                    v-on:click="loadImage()">
                    <img src="icons/image.svg"/>
                    Heightmap
                    <span class="instructions">drag</span>
                    <input id="load-image" ref="loadImage" type="file" v-on:change="loadImagePart2($event.target.files[0])" class="hidden" />
                </button>
            </div>
        </div>
        <button id="load" type="button" class="btn load" v-on:click="load()">
            <img src="icons/upload.svg"/>
            Load
            <span class="instructions">drag</span>
            <input id="load-input" ref="loadInput" type="file" v-on:change="loadPart2($event.target.files[0])" class="hidden" />
        </button>
        <button id="save" type="button" class="btn"  v-on:click="save">
            <img src="icons/download.svg"/>
            Save
            <span class="instructions">s</span>
        </button>
    </div>
</div>

 <div id="view-control" class="short-axis-group collapse control">

    <!-- RETURN -->
    <button type="button" class="btn" data-toggle="collapse" data-target="#view-control, #main-control">
        <img src="icons/down-arrow.svg"/>
        Return
    </button>
    
    <!-- SCALAR OPTIONS -->
    <button type="button" 
        class="btn" 
        v-bind:class="{'btn-secondary': ocean}" 
        v-on:click="setOcean(!ocean? 1:0)">
        <img src="icons/water.svg"/>
        Ocean
    </button>
    <button type="button" 
        class="btn" 
        v-if="isScalarViewSelected('satellite')"
        v-bind:class="{'btn-secondary': night}" 
        v-on:click="setShadows(!night? 1:0)">
        <img src="icons/weather-night.svg"/>
        Shadows
    </button>
    <button type="button" 
        class="btn" 
        v-if="isScalarViewSelected('satellite')"
        v-bind:class="{'btn-secondary': snow}" 
        v-on:click="setSnow(!snow? 1:0)">
        <img src="icons/snowflake.svg"/>
        Snow
    </button>
    <button type="button" 
        class="btn" 
        v-if="isScalarViewSelected('satellite')"
        v-bind:class="{'btn-secondary': sediment}" 
        v-on:click="setSediment(!sediment? 1:0)">
        <img src="icons/dirt.svg"/>
        Sediment
    </button>
    <button type="button" 
        class="btn" 
        v-if="isScalarViewSelected('satellite')"
        v-bind:class="{'btn-secondary': plant}" 
        v-on:click="setPlant(!plant? 1:0)">
        <img src="icons/leaf.svg"/>
        Plants
    </button>
    <button type="button" 
        class="btn" 
        v-for="option in scalarViewOptions"
        v-bind:class="getClass(option.value, scalarViewSelected)" 
        v-bind:data-value="option.value" 
        v-on:click="setScalarViewSelected(option.value)">
        <img v-bind:src="option.icon"/>
        {{option.name}}
    </button>

    <!-- VECTOR OPTIONS -->
    <button type="button" 
        class="btn" 
        data-toggle="tooltip"
        v-for="option in vectorViewOptions"
        v-bind:title="option.tip" 
        v-bind:class="getClass(option.value, vectorViewSelected)" 
        v-bind:data-value="option.value" 
        v-on:click="setVectorViewSelected(option.value)">
        <img v-bind:src="option.icon"/>
        {{option.name}}
    </button>

    <!-- PROJECTION OPTIONS -->
    <button type="button" 
        class="btn" 
        v-for="option in projectionOptions"
        v-bind:class="getClass(option.value, projectionSelected)" 
        v-bind:data-value="option.value" 
        v-on:click="setProjectionSelected(option.value)">
        <img v-bind:src="option.icon"/>
        {{option.name}}
    </button>
</div>

<div id="tune-control" class="tune-control collapse control" >
    <div class="short-axis-group">
        <div class="vertical-axis-group">
            <div class="horizontal-axis-group">
                <input id="seed" v-model="seed" class="form-control"></input>
            </div>
            <div class="horizontal-axis-group">
                <button type="button" class="btn" v-on:click="randomizeCrust">
                    <img src="icons/dice-6.svg"/>
                    Randomize
                </button>
                <button type="button" class="btn" v-on:click="copySeed">
                    <img v-if="!isSeedCopied" src="icons/clipboard-arrow-down.svg"/>
                    <img v-if="isSeedCopied" src="icons/clipboard-check.svg"/>
                    Copy Seed
                </button>
            </div>
            <div class="horizontal-axis-group">
                <button type="button" 
                    class="btn" 
                    v-bind:class="{'btn-secondary': supercontinentBreakup}" 
                    v-on:click="setSupercontinentBreakup(!supercontinentBreakup? 1:0)">
                    <img src="icons/clock.svg"/>
                    Supercontinent Breakup
                </button>
                <button type="button" class="btn tune-control" data-toggle="collapse" data-target="#main-control, .tune-control">
                    <img src="icons/down-arrow.svg"/>
                    Return
                </button>
            </div>
        </div>
        <div class="long-axis-group slider-label label">
            <div class="btn">
                <!-- <img src="icons/spinner-small.gif"/> -->
                <img src="icons/grid.svg"/>
                <div class="vertical-axis-group">
                    <div>Resolution</div>
                    <div>{{ format_count(cell_count).quantity }}{{ format_count(cell_count).unit }} cells</div>
                </div>
            </div>
            <div>
                <input type="range" v-model="resolution_level" class="is-long-axis-vertical slider-vertical" orient="vertical"
                    min="1" max="6" step="1">
                <input type="range" v-model="resolution_level" class="is-long-axis-horizontal" 
                    min="1" max="6" step="1">
            </div>
        </div>
        <div class="long-axis-group slider-label label">
            <div class="btn">
                <img src="icons/globe-model.svg"/>
                <div class="vertical-axis-group">
                    <div>Axial Tilt</div>
                    <div>{{axial_tilt_degrees}}°</div>
                </div>
            </div>
            <div class="">
                <input type="range" v-model="axial_tilt_degrees" class="is-long-axis-vertical slider-vertical" orient="vertical"
                    min="0" max="90" step="0.5">
                <input type="range" v-model="axial_tilt_degrees" class="is-long-axis-horizontal"
                    min="0" max="90" step="0.5">
            </div>
        </div>
        <div class="long-axis-group slider-label label">
            <div class="btn">
                <img src="icons/day-night.svg"/>
                <div class="vertical-axis-group">
                    <div>Day Length</div>
                    <div>{{ format_time(day_length).quantity }} {{ format_time(day_length).unit }}</div>
                </div>
            </div>
            <div class="">
                <input type="range" v-model="log10_day_length" class="is-long-axis-vertical slider-vertical" orient="vertical"
                    min="4.45" max="7.5" step="0.01">
                <input type="range" v-model="log10_day_length" class="is-long-axis-horizontal"
                    min="4.45" max="7.5" step="0.01">
            </div>
        </div>
        <!-- <div class="long-axis-group slider-label label">
            <div class="btn">
                <img src="icons/orbit.svg"/>
                <div class="vertical-axis-group">
                    <div>Semi-Major Axis</div>
                    <div>{{ semi_major_axis_au }}A.U.</div>
                </div>
            </div>
            <div class="">
                <input type="range" v-model="log10_semi_major_axis" class="is-long-axis-vertical slider-vertical" orient="vertical"
                    min="8.5" max="14.1" step="0.1">
                <input type="range" v-model="log10_semi_major_axis" class="is-long-axis-horizontal"
                    min="8.5" max="14.1" step="0.1">
            </div>
        </div> -->
    </div>
</div>

<a id="hidden-downloader" href="dataUrl" download="filename"></a>

<div id="stats">
</div>

<div id="chart" class="hidden-when-loading" v-if="isEnabled">
    <table class="stat">
        <tr>
            <td class="name">min</td>
            <td class="value">{{round(min)}}</td>
        </tr>
        <tr>
            <td class="name">max</td>
            <td class="value">{{round(max)}}</td>
        </tr>
    </table>

    <table class="stat">
        <tr>
            <td class="name">mean</td>
            <td class="value">{{round(mean)}}</td>
        </tr>
        <tr>
            <td class="name">median</td>
            <td class="value">{{round(median)}}</td>
        </tr>
    </table>
    <table class="stat">
        <tr>
            <td class="name">S.D.</td>
            <td class="value">{{round(stddev)}}</td>
        </tr>
    </table>
    <chartjs-line :width="200" :height="100" 
        :data="x" 
        :labels="y" 
        :bind="true"
        :pointbackgroundcolor="'rgba(255,255,255,0.2)'"
        :pointhoverbackgroundcolor="'rgba(255,255,255,0.2)'"
        :pointbordercolor="'rgba(255,255,255,0.2)'"
        :pointhoverbordercolor="'rgba(255,255,255,0.2)'"
        :bordercolor="'rgba(255,255,255,0.5)'"
        :backgroundcolor="'rgba(255,255,255,0.5)'" 
        :fill="true"
        :option="options">
    </chartjs-line>
</div>
<div id="drop-dialog" class="collapse">
    <h2>DRAG HERE</h2>
</div>
<div id="dialogs" class="vcenter">
    <div v-if="isNoWebGl" class="collapse hcenter dialog">
        <h2>Well, darn</h2>
        <p>It looks like your using a web browser without WebGL.</p>
        <p>WebGL is a technology that allows users to render graphics through the GPU from their web-browser.
        </p>
        <p>Writing a tectonics simulator in a browser is hard stuff. We're going to need all the tools we can get.
        </p>
        <p>It looks like you're using a browser that supports WebGL, but you just need to modify some settings, first. <a href="http://get.webgl.org/">Here</a> is a link that will help you get started.
        </p>
        <p>Until then, here's a video of what you're missing:
        </p>
        <iframe width="420" height="315" src="https://www.youtube.com/watch?v=MYMOHkVMIcA" frameborder="0" allowfullscreen></iframe>
    </div>
    <div v-if="isNoJs" class="loading-dialog">
        <img src="icons/spinner.svg"/>
        <h2>Initializing</h2>
    </div>
    <div v-if="isLoadingSave" class="collapse loading-dialog">
        <img src="icons/spinner.svg"/>
        <h2>Loading</h2>
    </div>
    <div class="notifications-dialog hidden-when-loading">
        <transition name="fade">
            <h3 v-for="notification in notifications">{{notification}}</h3>
        </transition>
    </div>
</div>

<script type="text/javascript">
    'use strict';
    
    //standards:
    // all spatial coordinates are xyz vectors on a unit sphere
    // all angles are in radians
    // all units are in MKS
    
    const IS_PROD = false;

    const body_tag = document.getElementsByTagName('body')[0];
    const drop_dialog_tag = document.getElementById('drop-dialog');
    const container_tag = document.getElementById('container');
    const stats_tag = document.getElementById('stats');
    const header_tag = document.getElementById('header');
    const hidden_downloader_tag = document.getElementById('hidden-downloader');
    const hidden_when_loading_tags = document.getElementsByClassName('hidden-when-loading');

    if( !window.WebGLRenderingContext ){
        process.exit(1);
    }

    const onSimLoadStart = new Event();
    const onSimLoadStop  = new Event();

    let sim, view;
    let renderStats, updateStats;
    let autosave_period;

    onSimLoadStart.subscribe(function() {
        for(const tag of hidden_when_loading_tags) { tag.style.display = 'none'; }
    });
    onSimLoadStop.subscribe(function() {
        for(const tag of hidden_when_loading_tags) { tag.style.display = 'block'; }
    });

    function loadUrl (url) {
        onSimLoadStart.fire();
        $.get( url, function( json ) {
            sim = JsonDeserializer.sim(json);
            onSimLoadStop.fire();
        });
    }
    function loadFile (file) {
        onSimLoadStart.fire();
        const reader = new FileReader();
        reader.onload = function(e) {
            sim = JsonDeserializer.sim(e.target.result);
            onSimLoadStop.fire();
        }
        reader.readAsText(file);
    }
    function loadImage (file) {
        onSimLoadStart.fire();
        const reader = new FileReader();
        reader.onload = function(e) {
            const data_url = e.target.result;
            // create image
            const image = new Image();
            // create canvas context from image
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            context.drawImage(image, 0, 0);
            image.onload = function(){
                canvas.width  = image.width;
                canvas.height = image.height;
                context.drawImage(image,0,0); // Or at whatever offset you like
                // generate crust from canvas context
                const elevations = ImageImporter.get_elevations_from_canvas_context(context, sim.focus().grid);
                CrustGenerator.get_crust_from_elevations(
                    elevations, 
                    CrustGenerator.modern_earth_attribute_height_maps, 
                    sim.focus().lithosphere.total_crust
                );

                onSimLoadStop.fire();
            };
            image.src = data_url;
        }
        reader.readAsDataURL(file);
    }

    // init the scene
    function init(){
        const querystring = [];
        const hashes = window.location.href.slice(window.location.href.indexOf('?') + 1).split('&')
        for(let i = 0; i < hashes.length; i++)
        {
            const hash = hashes[i].split('=');
            querystring.push(hash[0]);
            querystring[hash[0]] = hash[1];
        }

        
        const resolution_level = Math.min(6, parseInt(querystring['resolution_level'] || '5'));
        autosave_period      = parseInt(querystring['autosave']   || '0');

        view = new View(
            window.innerWidth, 
            window.innerHeight,
            scalarViews.satellite, 
            vectorViews.disabled, 
            projectionViews.orthographic,
        );

        onSimLoadStart.fire();

        sim = new Simulation({
            seed:  querystring['seed'] || (new Date).getTime().toString(),
            speed: 3.1*Units.DAY,
        });  

        const star_name_corpus = NameGenerator.tokenize_corpus(NameCorpii.arabic_star_names);
        const get_star_name = NameGenerator.get_length_distribution_generator(star_name_corpus, 25, {5:1,6:3,7:11,8:3,9:1}, 100);
        
        const planet_name_corpus = NameGenerator.tokenize_corpus(NameCorpii.greek_mythological_names);
        const get_planet_name = NameGenerator.get_length_distribution_generator(planet_name_corpus, 25, {5:1,6:3,7:11,8:3,9:1}, 100);
        const focus_name = get_planet_name(sim.random);
        
        const geometry = new THREE.IcosahedronGeometry(1, resolution_level);
        const universe = new Universe({
            bodies: {
                'star': {
                    type: 'star',
                    id  : 'star',
                    name: get_star_name(sim.random),
                    mass: Units.SOLAR_MASS,
                },
                'world': {
                    type: 'world',
                    id  : 'world',
                    name: focus_name,
                    grid: { 
                        faces:   geometry.faces.map(f => {  
                            return {a: f.a, b: f.b, c: f.c}  
                            }), 
                        vertices:geometry.vertices.map(v => {  
                            return {x: v.x, y: v.y, z: v.z}  
                            }), 
                    }, 
                },
            },
            config: {
                'stellar orbit': Math.PI/2
            },
            cycles: {
                'galactic orbit': {
                    id:       'galactic orbit',
                    children:  ['stellar orbit'],
                    body:       'star',
                    motion: { // motion mirrors orbit of sun around galactic center
                        type: 'orbit',
                        semi_major_axis: 2.35e20, // meters
                        effective_combined_mass: 1.262e41, // kg, back calculated to achieve period of 250 million years
                    },
                    invariant_insolation: true,
                },
                'stellar orbit': {
                    id:       'stellar orbit',
                    parent:   'galactic orbit',
                    children: ['precession'],
                    motion: {
                        type: 'orbit',
                        semi_major_axis: 1. * Units.ASTRONOMICAL_UNIT,
                        eccentricity: 0.0167,
                        inclination: Math.PI * 5e-5/180,
                        longitude_of_ascending_node: Math.PI * -11/180,
                        effective_combined_mass: 2e30, // kg
                    },    
                    invariant_insolation: false,
                },
                'precession': {
                    id:       'precession',
                    parent:   'stellar orbit',
                    children: ['spin'],
                    motion: { 
                        type: 'spin',
                        angular_speed: 2*Math.PI/(25860 * Units.YEAR),
                    },    
                    invariant_insolation: true,
                },
                'spin': {
                    id:       'spin',
                    parent:   'precession',
                    children: [],
                    body:     'world',
                    motion: { 
                        type: 'spin',
                        angular_speed: 2*Math.PI/(60*60*24),
                        axial_tilt: 23.5 * Math.PI/180,
                    },   
                    invariant_insolation: false,
                },
            },
        });
        const world = universe.bodies['world'];
        CrustGenerator.get_crust_from_height_ranks(
            SphericalGeometry.get_random_surface_field(world.grid, sim.random), 
            CrustGenerator.modern_earth_hypsography, 
            CrustGenerator.modern_earth_attribute_height_maps, 
            sim.random,
            world.lithosphere.total_crust
        );
        sim.model(universe);
        sim.focus(world);

        if (querystring['load']) {
            loadUrl(querystring['load']); // TODO: rework this
        } 

        onSimLoadStop.fire();

        container_tag.appendChild(view.getDomElement());
        
        if(!IS_PROD){
            // add Stats.js - https://github.com/mrdoob/renderStats.js
            renderStats = new Stats();
            stats_tag.appendChild( renderStats.domElement );

            updateStats = new Stats();
            stats_tag.appendChild( updateStats.domElement );

            header_tag.style.display = 'none';
        }
    }

    function autosave() {
        if (!autosave_period) { return; }
        setTimeout(autosave, 1000*autosave_period);
        saveVue.save();
    }

    // animation loop
    function animate() {
        // push to render queue and loop
        // - it has to be at the begining of the function
        // - to learn more: https://www.youtube.com/watch?v=8aGhZQkoFbQ
        requestAnimationFrame( animate );

        view.render();

        if(!IS_PROD){
            renderStats.update();
        }
    }

    function update(){
        // push to task queue and loop
        // - it has to be at the begining of the function
        //maximum refresh rate of 20fps
        setTimeout(update, IS_PROD? 1000/20 : 0);

        sim.update();
        view.update(sim); 

        if(!IS_PROD){
            updateStats.update();
        }
    }
    

    function format_count (num, rollover, precision){
        const units = ['', 'k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y']
        let quantity = num;
        let unit = units.shift();
        while(quantity > rollover) {
            unit = units.shift();
            quantity /= rollover;
        }
        return {
            quantity:     quantity.toPrecision(precision).toString(), 
            unit:         unit,
        };
    }
    function format_time (seconds, precision){
        const quantity = seconds;
        if (quantity < Units.MINUTE) { 
            return { unit: 's',  quantity:  (quantity/Units.SECOND).toPrecision(precision).toString() }; 
        } else if (quantity < Units.HOUR) {
            return { unit: 'm',  quantity:  (quantity/Units.MINUTE).toPrecision(precision).toString() }; 
        } else if (quantity < Units.DAY) {
            return { unit: 'hr',  quantity: (quantity/Units.HOUR).toPrecision(precision).toString() }; 
        } else if (quantity < Units.WEEK) {
            return { unit: 'dy',  quantity: (quantity/Units.DAY).toPrecision(precision).toString() }; 
        } else if (quantity < Units.MONTH) {
            return { unit: 'wk',  quantity: (quantity/Units.WEEK).toPrecision(precision).toString() }; 
        } else if (quantity < Units.YEAR) {
            return { unit: 'mo',  quantity: (quantity/Units.MONTH).toPrecision(precision).toString() }; 
        }
        const formatted = format_count(quantity/Units.YEAR, 1000, 3);
        formatted.unit += 'y';
        return formatted;
    }

    function download(url, filename) {
        hidden_downloader_tag.setAttribute('href', url);
        hidden_downloader_tag.setAttribute('download', filename);
        hidden_downloader_tag.click();
    }


    window.addEventListener('keyup', function(event) {
      if (event.keyCode == 80) { //p
          screenshotVue.capture();
      }
      if (event.keyCode == 83) { //s
          saveVue.save();
      }
      if (event.keyCode == 188) { // <
          timeMenuVue.slower();
      }
      if (event.keyCode == 190) { // >
          timeMenuVue.faster();
      }
      if (event.keyCode == 191) { // /
          timeMenuVue.togglePause();
      }
      if (event.keyCode == 32) { // space
          timeMenuVue.togglePause();
      }
    });

    let last_drag_entered;
    body_tag.addEventListener('dragover', function(e) {
            e.preventDefault();
            e.stopPropagation();
        } );
    body_tag.addEventListener('dragenter', function(e) {
            e.preventDefault();
            e.stopPropagation();
            last_drag_entered = e.target;
            drop_dialog_tag.style.display = 'block';
        } );
    body_tag.addEventListener('dragleave', function(e) {
            e.preventDefault();
            e.stopPropagation();
            if(last_drag_entered == e.target){
                drop_dialog_tag.style.display = 'none';
            }
        } );
    body_tag.addEventListener('drop', function(e) {
            e.preventDefault();
            e.stopPropagation();
            drop_dialog_tag.style.display = 'none';
            while(!e.dataTransfer && e.originalEvent){
                e = e.originalEvent;
            }
            loadFile(e.dataTransfer.files[0]);
        } );

    const dialogVue = new Vue({
      el: '#dialogs',
      data: {
          isNoWebGl: false,
          isNoJs: false,
          isLoadingSave: false,
          notifications: []
      },
      created: function() {
          this.isNoWebGl = window.WebGLRenderingContext;
          const _this = this;
          onSimLoadStart.subscribe(function() {
              _this.isLoadingSave = true;
          })
          onSimLoadStop.subscribe(function() {
              _this.isLoadingSave = false;
          })
      },
      methods: {
          notify: function(notification) {
              this.notifications.shift()
              this.notifications.push(notification);
              const _this = this;
              setInterval(function() {
                  _this.notifications.shift()
              }, 3000);
          }
      }
    });
    
    const loadVue = new Vue({
      el: '#load',
      methods: {
          load: function() {
              // HACK: only <input> is capable of loading a file, 
              // but we need to use a button for bootstrap styling.
              // The solution is for the button to trigger click event
              // on a hidden file input element.
              this.$refs.loadInput.click();
          },
          loadPart2: function(file) {
              loadFile(file);
          }
      }
    });

    const saveVue = new Vue({
      el: '#save',
      methods: {
        save(event) {
            const stringified = JsonSerializer.sim(sim);
            const blob = new Blob([stringified], {type : 'application/json'});
            const blobUrl = URL.createObjectURL(blob);
            const elapsed_time = format_time(sim.elapsed_time);
            const filename = `${sim.focus().name}-${elapsed_time.quantity}${elapsed_time.unit}.sim`;
            download(blobUrl, filename);
        }
      }
    });

    const exportVue = new Vue({
      el: '#export',
      methods: {
        csv(event) {
            const content = CsvExporter.world(sim.focus());
            const blob = new Blob([content], {type : 'text/csv'});
            const blobUrl = URL.createObjectURL(blob);
            const elapsed_time = format_time(sim.elapsed_time);
            const filename = `${sim.focus().name}-${elapsed_time.quantity}${elapsed_time.unit}.csv`;
            download(blobUrl, filename);
        }
      }
    });

    const importVue = new Vue({
      el: '#import',
      methods: {
          loadImage: function() {
              // HACK: only <input> is capable of loading a file, 
              // but we need to use a button for bootstrap styling.
              // The solution is for the button to trigger click event
              // on a hidden file input element.
              this.$refs.loadImage.click();
          },
          loadImagePart2: function(file) {
              loadImage(file);
          }
      }
    });

    const screenshotVue = new Vue({
      el: '#screenshot',
      data: {
          isEnabled: false,
      },
      created: function() {
          this.isEnabled = window.WebGLRenderingContext;
      },
      methods: {
          capture(event) {
              const elapsed_time = format_time(sim.elapsed_time);
              const dataUrl = view.getScreenshotDataURL();
              const filename = `${sim.focus().name}-${elapsed_time.quantity}${elapsed_time.unit}.png`
              download(dataUrl, filename);
          }
      }
    });

    const timeMenuVue = new Vue({
      el: '#main-control',
      data: {
            paused: false,
            speed_i: 1,
            speeds: [
                {    name:'1s/s',      scale: 1,               },
                {    name:'1m/s',      scale: 60,              },
                {    name:'1hr/s',     scale: 60*60,           },
                {    name:'1dy/s',     scale: 1  *Units.DAY    },
                {    name:'1wk/s',     scale: 7  *Units.DAY    },
                {    name:'1mo/s',     scale: 31 *Units.DAY    },
                {    name:'1y/s',      scale: 1  *Units.YEAR,  },
                {    name:'10y/s',     scale: 10 *Units.YEAR,  },
                {    name:'100y/s',    scale: 100*Units.YEAR,  },
                {    name:'1ky/s',     scale: 1e3*Units.YEAR,  },
                {    name:'10ky/s',    scale: 1e4*Units.YEAR,  },
                {    name:'100ky/s',   scale: 1e5*Units.YEAR,  },
                {    name:'1My/s',     scale: 1e6*Units.YEAR,  },
            ],
            elapsed_time: 0,
            isSeasonVisible: true,
      },
      created: function() {
          const _this = this;
          const update_time_period = 0.5;
          let isLoadingSave = true;

          function update_time() {
              if (isLoadingSave) { return; }
              _this.elapsed_time = sim.elapsed_time;
              sim.speed = _this.speeds[_this.speed_i].scale;
              sim.paused = _this.paused;
              setTimeout(update_time, 1000*update_time_period);
          }
          update_time();
          onSimLoadStart.subscribe(function() {
              isLoadingSave = true;
          })
          onSimLoadStop.subscribe(function() {
              isLoadingSave = false;
              update_time();
          })
      },
      methods: {
        speed: function(speed_i) {
            this.speed_i = speed_i
            sim.speed = this.speeds[this.speed_i].scale;
        },
        togglePause: function() {
            this.paused = !this.paused;
            sim.toggle_pause();
        },
        faster: function() {
            this.speed_i = Math.min(this.speed_i+1, this.speeds.length-1);
            sim.speed = this.speeds[this.speed_i].scale;
        },
        slower: function() {
            this.speed_i = Math.max(this.speed_i-1, 0);
            sim.speed = this.speeds[this.speed_i].scale;
        },
        format_count: function(time) {
            return format_count(time/Units.YEAR, 1000, 3)
        },
    }
    });

    const scalarViewVue = new Vue({
      el: '#view-control',
      data: {
        ocean: 1,
        ocean_target: 1,
        night: 1,
        night_target: 1,
        snow: 1,
        snow_target: 1,
        sediment: 1,
        sediment_target: 1,
        plant: 1,
        plant_target: 1,
        scalarViewSelected: 'satellite',
        scalarViewOptions: [
          {name: 'Satellite', value: 'satellite', icon: 'icons/satellite-variant.svg' },
          {name: 'Topographic map', value: 'topographic', icon: 'icons/terrain.svg'},
          {name: 'Height map', value: 'alt', icon: 'icons/terrain-length.svg'},
          {name: 'Normal map', value: 'surface_normal_map', icon: 'icons/terrain-arrows.svg'},
          {name: 'Plant Productivity', value: 'npp', icon: 'icons/leaf.svg'},
          {name: 'Air Temperature', value: 'temp', icon: 'icons/air-temperature.svg' },
          {name: 'Air Pressure', value: 'surface_air_pressure', icon: 'icons/air-pressure.svg' },
          {name: 'Precipitation', value: 'precipitation', icon: 'icons/weather-raining.svg'},
          {name: 'Crust Age', value: 'age', icon: 'icons/rock-age.svg'},
          {name: 'Crust Density', value: 'density', icon: 'icons/rock-scale.svg'},
          {name: 'Crust Thickness', value: 'thickness', icon: 'icons/rock-length.svg'},
          {name: 'Plates', value: 'plates', icon: 'icons/puzzle.svg'},
        ],
        vectorViewSelected: 'disabled',
        vectorViewOptions: [
          { name: "No Arrows", value: "disabled", icon: "icons/none.svg" },
          { name: "Mantle Flow", value: "asthenosphere_velocity", icon: "icons/fire-flow.svg" },
          // { name: "Plate Motion", value: "plate_velocity", icon: "icons/plate-motion.svg" },
          { name: "Wind Speed", value: "surface_air_velocity", icon: "icons/air-flow.svg" },
        ],
        projectionSelected: 'orthographic',
        projectionOptions: [
          { name: "Globe", value: "orthographic", icon: "icons/earth.svg" },
          { name: "Map", value: "equirectangular", icon: "icons/map.svg" },
          { name: "Texture", value: "texture", icon: "icons/texture.svg" },
        ],
        isFullscreen: false,
        isFullscreenVisible: false,
      },
      created: function() {},
      methods: {
        setProjectionSelected: function(value) {
            if (this.projectionSelected == value) { value = this.projectionOptions[0].value; }
            this.projectionSelected = value;
            view.setProjectionView(projectionViews[value]);
        },
        setVectorViewSelected: function(value) {
          if (this.selected == value) { value = this.vectorViewOptions[0].value; }
            const option = this.vectorViewOptions.filter(x => x.value == value)[0];
            this.selected = value;
            view.setVectorView(vectorViews[value]);
        },
        setScalarViewSelected: function(value) {
            if (this.scalarViewSelected == value) { value = this.scalarViewOptions[0].value; }
              const option = this.scalarViewOptions.filter(x => x.value == value)[0];
            this.scalarViewSelected = value;
            view.setScalarView(scalarViews[value]);
        },
        isScalarViewSelected: function(value) {
            return {
                satellite: true,
            }[this.scalarViewSelected];
        },
        setOcean: function(value) {
            this.ocean_target = value;
            const v = this;
            // TODO: hook this up to actual fps
            const fps = 30
            const timestep = 1000/fps;     //milliseconds
            const duration = 250;         //milliseconds
            const increment = timestep/duration;
            chartVue.setOceanVisibility(value);
            const timer = setInterval(function() {
                v.ocean += Math.sign(v.ocean_target - v.ocean) * increment
                if (Math.abs(v.ocean_target - v.ocean) < 2*increment) {
                  clearInterval(timer); 
                  v.ocean = v.ocean_target;
                }
                view.uniform('ocean_visibility', (v.ocean)?(1.0):(-0.2));
            }, timestep);
        },
        setShadows: function(value) {
            this.night_target = value;
            const v = this;
            // TODO: hook this up to actual fps
            const fps = 30
            const timestep = 1000/fps;     //milliseconds
            const duration = 250;         //milliseconds
            const increment = timestep/duration;
            const timer = setInterval(function() {
                v.night += Math.sign(v.night_target - v.night) * increment
                if (Math.abs(v.night_target - v.night) < 2*increment) {
                  clearInterval(timer); 
                  v.night = v.night_target;
                }
                view.uniform('shadow_visibility', (v.night)?(1.0):(0.0));
            }, timestep);
        },
        setSnow: function(value) {
            this.snow_target = value;
            const v = this;
            // TODO: hook this up to actual fps
            const fps         = 30
            const timestep     = 1000/fps;    //milliseconds
            const duration     = 250;         //milliseconds
            const increment = timestep/duration;
            const timer = setInterval(function() {
                v.snow += Math.sign(v.snow_target - v.snow) * increment
                if (Math.abs(v.snow_target - v.snow) < 2*increment) {
                  clearInterval(timer); 
                  v.snow = v.snow_target;
                }
                view.uniform('snow_visibility', (v.snow)?(1.0):(0.0));
            }, timestep);
        },
        setSediment: function(value) {
            this.sediment_target = value;
            const v = this;
            // TODO: hook this up to actual fps
            const fps         = 30
            const timestep     = 1000/fps;    //milliseconds
            const duration     = 250;         //milliseconds
            const increment = timestep/duration;
            if (v.plant_target > v.sediment_target) {
                v.setPlant(v.sediment_target);
            }
            const timer = setInterval(function() {
                v.sediment += Math.sign(v.sediment_target - v.sediment) * increment
                if (Math.abs(v.sediment_target - v.sediment) < 2*increment) {
                  clearInterval(timer); 
                  v.sediment = v.sediment_target;
                }
                view.uniform('sediment_visibility', (v.sediment)?(1.0):(0.0));
            }, timestep);
        },
        setPlant: function(value) {
            this.plant_target = value;
            const v = this;
            // TODO: hook this up to actual fps
            const fps         = 30
            const timestep     = 1000/fps;    //milliseconds
            const duration     = 250;         //milliseconds
            const increment = timestep/duration;
            if (v.plant_target > v.sediment_target) {
                v.setSediment(v.plant_target);
            }
            const timer = setInterval(function() {
                v.plant += Math.sign(v.plant_target - v.plant) * increment
                if (Math.abs(v.plant_target - v.plant) < 2*increment) {
                  clearInterval(timer); 
                  v.plant = v.plant_target;
                }
                view.uniform('plant_visibility', (v.plant)?(1.0):(0.0));
            }, timestep);
        },
        getClass: function(value, scalarViewSelected) {
            return value == scalarViewSelected? 'btn-secondary' : '';
        },
      }
    });

    const settingsVue = new Vue({
      el: '#tune-control',
      data: {
        supercontinentBreakup : 1,
        seed                  : '',
        isSeedCopied          : 0,
        resolution_level      : 5,
        cell_count            : 0,
        axial_tilt_degrees    : 23.5,
        log10_day_length      : Math.log10(Units.DAY),
        day_length            : Units.DAY,
        log10_semi_major_axis : Math.log10(Units.ASTRONOMICAL_UNIT),
        semi_major_axis_au    : 1,
      },
      created: function() {
          const _this = this;
          onSimLoadStop.subscribe(function() { 
            _this.seed = sim.seed;
            _this.cell_count = sim.focus().grid.vertices.length;
          });
      },
      watch: {
        'seed': function(new_value, old_value) {
            // TODO: reset sim to match the new seed
        },
        'axial_tilt_degrees': function(new_value, old_value) {
            sim.model().cycles['spin'].motion.axial_tilt = new_value * Math.PI/180;
        },
        'log10_day_length': function(new_value, old_value) {
            this.day_length = Math.pow(10, new_value);
            sim.model().cycles['spin'].motion.angular_speed = 2*Math.PI/this.day_length;
        },
        'log10_semi_major_axis': function(new_value, old_value) {
            this.semi_major_axis_au = (Math.pow(10, new_value)/Units.ASTRONOMICAL_UNIT).toPrecision(3).toString();
            sim.model().cycles['stellar orbit'].motion.semi_major_axis = Math.pow(10, new_value);
        },
        'resolution_level': function(new_value, old_value) {
            onSimLoadStart.fire();
            // preserve the same exact state of world in every way except grid
            const world_params = sim.focus().getParameters();
            const geometry = new THREE.IcosahedronGeometry(1, new_value);
            world_params.grid = { 
                    faces:   geometry.faces.map(f => {  
                        return {a: f.a, b: f.b, c: f.c}  
                        }), 
                    vertices:geometry.vertices.map(v => {  
                        return {x: v.x, y: v.y, z: v.z}  
                        }), 
                };
            // eliminate anything that would store a raster in a buffer to prevent overflow
            world_params.lithosphere.plates = [];
            world_params.lithosphere.total_crust = undefined;
            const world = new World(world_params);
            CrustGenerator.get_crust_from_height_ranks(
                SphericalGeometry.get_random_surface_field(world.grid, sim.random), 
                CrustGenerator.modern_earth_hypsography, 
                CrustGenerator.modern_earth_attribute_height_maps, 
                sim.random,
                world.lithosphere.total_crust
            );
            
            const universe = sim.model();
            universe.bodies[world.id] = world;
            // HACK: we need to call initialize() on universe again because 
            // it's the only thing that passes the dependencies required by world.
            // This is a huge pain in the ass and this is the exact reason why
            //   you shouldn't play with stateful objects, kids. 
            // TODO: refactor the universe
            universe.initialize();
            sim.focus(world);

            onSimLoadStop.fire();
        }
      },
      methods: {
        format_count: function(count) {
            return format_count(count, 1000, 3);
        },
        format_time: function(seconds) {
            return format_time(seconds, 3);
        },
        setSupercontinentBreakup: function(value) {
            this.supercontinentBreakup = value;
            if (!this.supercontinentBreakup) {
                sim.focus().lithosphere.supercontinentCycle.duration = Infinity;
            } else {
                sim.focus().lithosphere.supercontinentCycle.duration = 0;
            }
        },
        randomizeCrust: function() {
            const world = sim.focus();
            CrustGenerator.get_crust_from_height_ranks(
                SphericalGeometry.get_random_surface_field(world.grid, sim.random), 
                CrustGenerator.modern_earth_hypsography, 
                CrustGenerator.modern_earth_attribute_height_maps, 
                sim.random,
                world.lithosphere.total_crust
            );
        },
        copySeed: function() {
            const copyText = document.getElementById("seed");
            copyText.select();
            document.execCommand("copy");
        }
      }
    });

    Vue.use(VueCharts);
    const chartVue = new Vue({
        el: '#chart',
        data:{
            isEnabled: false,
            min: 0,
            max: 0,
            mean: 0,
            median: 0,
            stddev: 0,
            x: [],
            y: [],
            ocean_visibility: 1,
            options: {
                legend: {display: false}, 
                animation : false,
                scales: {
                    xAxes: [{
                        ticks: {
                          fontColor: '#FFFFFF'
                        }
                    }],
                    yAxes: [{
                        scaleLabel: {
                            display: true,
                            labelString: '% surface'
                        },
                        ticks: {
                          fontColor: '#FFFFFF'
                        },
                    }]
                }
            }
        },
        created: function() {
            const _this = this;
            onSimLoadStop.subscribe(function() {
                view.updateChart(_this.$data, sim, _this.$data);
            });
        },
        methods: {
            setOceanVisibility(value){
                this.ocean_visibility = value? 1:0;
            },
            round(x) {
                return Math.round(x);
            }
        }
    });
    
    init();
    animate();
    update();
    autosave();

    // HACK: not sure why, but initializing speed at 1m/s will cause 
    //  display to break when user increases speed past 1wk/s.
    // We set speed to 1m/s here to work around this.
    timeMenuVue.speed(1)

    // once everything is loaded, instruct the user how to start
    dialogVue.notify("click ▶▶ or press > to begin")
</script>
</body>
</html>
V